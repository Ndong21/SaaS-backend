// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: stocks.sql

package repo

import (
	"context"
)

const countSalesTransactions = `-- name: CountSalesTransactions :one
SELECT COUNT(*) AS transaction_count
FROM sales
`

func (q *Queries) CountSalesTransactions(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countSalesTransactions)
	var transaction_count int64
	err := row.Scan(&transaction_count)
	return transaction_count, err
}

const createCatalog = `-- name: CreateCatalog :one
INSErT INTO "catalog" (product_id, unit_price)
VALUES ($1, $2)
RETURNING id, product_id, unit_price
`

type CreateCatalogParams struct {
	ProductID string `json:"product_id"`
	UnitPrice int32  `json:"unit_price"`
}

func (q *Queries) CreateCatalog(ctx context.Context, arg CreateCatalogParams) (Catalog, error) {
	row := q.db.QueryRow(ctx, createCatalog, arg.ProductID, arg.UnitPrice)
	var i Catalog
	err := row.Scan(&i.ID, &i.ProductID, &i.UnitPrice)
	return i, err
}

const createCategory = `-- name: CreateCategory :one
INSERT INTO "categories" (category_name, category_description)
VALUES ($1,$2)
RETURNING id, category_name, category_description
`

type CreateCategoryParams struct {
	CategoryName        string `json:"category_name"`
	CategoryDescription string `json:"category_description"`
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (Category, error) {
	row := q.db.QueryRow(ctx, createCategory, arg.CategoryName, arg.CategoryDescription)
	var i Category
	err := row.Scan(&i.ID, &i.CategoryName, &i.CategoryDescription)
	return i, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO "products" (category_id, product_name)
VALUES ($1,$2)
RETURNING id, category_id, product_name
`

type CreateProductParams struct {
	CategoryID  string `json:"category_id"`
	ProductName string `json:"product_name"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct, arg.CategoryID, arg.ProductName)
	var i Product
	err := row.Scan(&i.ID, &i.CategoryID, &i.ProductName)
	return i, err
}

const createPurchase = `-- name: CreatePurchase :one
INSErT INTO "purchases" (product_id, total_price, quantity, vendor_id)
VALUES ($1, $2, $3, $4)
RETURNING id, product_id, total_price, quantity, vendor_id, created_at, cashier_id
`

type CreatePurchaseParams struct {
	ProductID  string  `json:"product_id"`
	TotalPrice int32   `json:"total_price"`
	Quantity   int32   `json:"quantity"`
	VendorID   *string `json:"vendor_id"`
}

func (q *Queries) CreatePurchase(ctx context.Context, arg CreatePurchaseParams) (Purchase, error) {
	row := q.db.QueryRow(ctx, createPurchase,
		arg.ProductID,
		arg.TotalPrice,
		arg.Quantity,
		arg.VendorID,
	)
	var i Purchase
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.TotalPrice,
		&i.Quantity,
		&i.VendorID,
		&i.CreatedAt,
		&i.CashierID,
	)
	return i, err
}

const createSale = `-- name: CreateSale :one
INSErT INTO "sales" (product_id, unit_price, quantity, cashier_id)
VALUES ($1, $2, $3, $4)
RETURNING id, product_id, unit_price, quantity, created_at, cashier_id
`

type CreateSaleParams struct {
	ProductID string  `json:"product_id"`
	UnitPrice int32   `json:"unit_price"`
	Quantity  int32   `json:"quantity"`
	CashierID *string `json:"cashier_id"`
}

func (q *Queries) CreateSale(ctx context.Context, arg CreateSaleParams) (Sale, error) {
	row := q.db.QueryRow(ctx, createSale,
		arg.ProductID,
		arg.UnitPrice,
		arg.Quantity,
		arg.CashierID,
	)
	var i Sale
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.UnitPrice,
		&i.Quantity,
		&i.CreatedAt,
		&i.CashierID,
	)
	return i, err
}

const createVendor = `-- name: CreateVendor :one
INSErT INTO "vendors" (vendor_name, vendor_location, description)
VALUES ($1, $2, $3)
RETURNING id, vendor_name, vendor_location, description
`

type CreateVendorParams struct {
	VendorName     string `json:"vendor_name"`
	VendorLocation string `json:"vendor_location"`
	Description    string `json:"description"`
}

func (q *Queries) CreateVendor(ctx context.Context, arg CreateVendorParams) (Vendor, error) {
	row := q.db.QueryRow(ctx, createVendor, arg.VendorName, arg.VendorLocation, arg.Description)
	var i Vendor
	err := row.Scan(
		&i.ID,
		&i.VendorName,
		&i.VendorLocation,
		&i.Description,
	)
	return i, err
}

const deleteCatalog = `-- name: DeleteCatalog :exec
DELETE FROM catalog
WHERE id = $1
`

func (q *Queries) DeleteCatalog(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteCatalog, id)
	return err
}

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM categories
WHERE id = $1
`

func (q *Queries) DeleteCategory(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteCategory, id)
	return err
}

const deletePurchase = `-- name: DeletePurchase :exec
DELETE FROM purchases
WHERE id = $1
`

func (q *Queries) DeletePurchase(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deletePurchase, id)
	return err
}

const deleteSale = `-- name: DeleteSale :exec
DELETE FROM sales
WHERE id = $1
`

func (q *Queries) DeleteSale(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteSale, id)
	return err
}

const deleteproduct = `-- name: Deleteproduct :exec
DELETE FROM products
WHERE id = $1
`

func (q *Queries) Deleteproduct(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteproduct, id)
	return err
}

const getAllCategories = `-- name: GetAllCategories :many
SELECT 
id,
category_name,
category_description
FROM categories
`

func (q *Queries) GetAllCategories(ctx context.Context) ([]Category, error) {
	rows, err := q.db.Query(ctx, getAllCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Category{}
	for rows.Next() {
		var i Category
		if err := rows.Scan(&i.ID, &i.CategoryName, &i.CategoryDescription); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProducts = `-- name: GetAllProducts :many
WITH purchase_totals AS (
  SELECT 
    product_id,
    SUM(quantity) AS total_purchased
  FROM purchases
  GROUP BY product_id
),
sales_totals AS (
  SELECT 
    product_id,
    SUM(quantity) AS total_sold
  FROM sales
  GROUP BY product_id
)
SELECT 
  pr.id AS product_id,
  pr.product_name,
  c.category_name,
  COALESCE(pur.total_purchased, 0) - COALESCE(sal.total_sold, 0) AS quantity_left
FROM 
  products pr
JOIN 
  categories c ON pr.category_id = c.id
LEFT JOIN 
  purchase_totals pur ON pr.id = pur.product_id
LEFT JOIN 
  sales_totals sal ON pr.id = sal.product_id
`

type GetAllProductsRow struct {
	ProductID    string `json:"product_id"`
	ProductName  string `json:"product_name"`
	CategoryName string `json:"category_name"`
	QuantityLeft int32  `json:"quantity_left"`
}

func (q *Queries) GetAllProducts(ctx context.Context) ([]GetAllProductsRow, error) {
	rows, err := q.db.Query(ctx, getAllProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllProductsRow{}
	for rows.Next() {
		var i GetAllProductsRow
		if err := rows.Scan(
			&i.ProductID,
			&i.ProductName,
			&i.CategoryName,
			&i.QuantityLeft,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPurchases = `-- name: GetAllPurchases :many
SELECT 
  p.id,
  pr.product_name,
  p.total_price,
  p.quantity,
  TO_CHAR(p.created_at, 'DD-MM-YYYY') AS "purchase_date",
  v.vendor_name
FROM 
  purchases p
JOIN 
  products pr ON p.product_id = pr.id
LEFT JOIN 
  vendors v ON p.vendor_id = v.id
LEFT JOIN users u ON u.id = p.cashier_id
`

type GetAllPurchasesRow struct {
	ID           string  `json:"id"`
	ProductName  string  `json:"product_name"`
	TotalPrice   int32   `json:"total_price"`
	Quantity     int32   `json:"quantity"`
	PurchaseDate string  `json:"purchase_date"`
	VendorName   *string `json:"vendor_name"`
}

func (q *Queries) GetAllPurchases(ctx context.Context) ([]GetAllPurchasesRow, error) {
	rows, err := q.db.Query(ctx, getAllPurchases)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllPurchasesRow{}
	for rows.Next() {
		var i GetAllPurchasesRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductName,
			&i.TotalPrice,
			&i.Quantity,
			&i.PurchaseDate,
			&i.VendorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSales = `-- name: GetAllSales :many
SELECT 
  s.id,
  pr.product_name,
  s.unit_price,
  s.quantity,
  s.unit_price * s.quantity AS total_price,
  TO_CHAR(s.created_at, 'DD-MM-YYYY') AS "Sale_date"
  --u.name AS cashier
FROM 
  sales s
JOIN 
  products pr ON s.product_id = pr.id
LEFT JOIN users u ON u.id = s.cashier_id
`

type GetAllSalesRow struct {
	ID          string `json:"id"`
	ProductName string `json:"product_name"`
	UnitPrice   int32  `json:"unit_price"`
	Quantity    int32  `json:"quantity"`
	TotalPrice  int32  `json:"total_price"`
	SaleDate    string `json:"Sale_date"`
}

func (q *Queries) GetAllSales(ctx context.Context) ([]GetAllSalesRow, error) {
	rows, err := q.db.Query(ctx, getAllSales)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllSalesRow{}
	for rows.Next() {
		var i GetAllSalesRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductName,
			&i.UnitPrice,
			&i.Quantity,
			&i.TotalPrice,
			&i.SaleDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllVendors = `-- name: GetAllVendors :many
SELECT 
id,
vendor_name,
vendor_location,
COALESCE(description, '') AS description
FROM vendors
`

func (q *Queries) GetAllVendors(ctx context.Context) ([]Vendor, error) {
	rows, err := q.db.Query(ctx, getAllVendors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Vendor{}
	for rows.Next() {
		var i Vendor
		if err := rows.Scan(
			&i.ID,
			&i.VendorName,
			&i.VendorLocation,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCatalog = `-- name: GetCatalog :many
SELECT 
p.product_name,
c.unit_price
FROM products p 
JOIN catalog c ON p.id = c.product_id
`

type GetCatalogRow struct {
	ProductName string `json:"product_name"`
	UnitPrice   int32  `json:"unit_price"`
}

func (q *Queries) GetCatalog(ctx context.Context) ([]GetCatalogRow, error) {
	rows, err := q.db.Query(ctx, getCatalog)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCatalogRow{}
	for rows.Next() {
		var i GetCatalogRow
		if err := rows.Scan(&i.ProductName, &i.UnitPrice); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loadTime = `-- name: LoadTime :one
SELECT NOW()
`

func (q *Queries) LoadTime(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRow(ctx, loadTime)
	var now interface{}
	err := row.Scan(&now)
	return now, err
}

const top5BestSellingProductsByRevenue = `-- name: Top5BestSellingProductsByRevenue :many
SELECT 
  p.id AS product_id,
  p.product_name,
  SUM(s.quantity) AS total_quantity_sold,
  SUM(s.quantity * s.unit_price) AS total_revenue
FROM sales s
JOIN products p ON s.product_id = p.id
GROUP BY p.id, p.product_name
ORDER BY total_revenue DESC
LIMIT 5
`

type Top5BestSellingProductsByRevenueRow struct {
	ProductID         string `json:"product_id"`
	ProductName       string `json:"product_name"`
	TotalQuantitySold int64  `json:"total_quantity_sold"`
	TotalRevenue      int64  `json:"total_revenue"`
}

func (q *Queries) Top5BestSellingProductsByRevenue(ctx context.Context) ([]Top5BestSellingProductsByRevenueRow, error) {
	rows, err := q.db.Query(ctx, top5BestSellingProductsByRevenue)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Top5BestSellingProductsByRevenueRow{}
	for rows.Next() {
		var i Top5BestSellingProductsByRevenueRow
		if err := rows.Scan(
			&i.ProductID,
			&i.ProductName,
			&i.TotalQuantitySold,
			&i.TotalRevenue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const totalSales = `-- name: TotalSales :one
SELECT SUM(unit_price * quantity) AS total_sales
FROM sales
`

func (q *Queries) TotalSales(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, totalSales)
	var total_sales int64
	err := row.Scan(&total_sales)
	return total_sales, err
}

const updateCategory = `-- name: UpdateCategory :one
UPDATE categories
SET category_name = $1, category_description = $2
WHERE id = $3
RETURNING id, category_name, category_description
`

type UpdateCategoryParams struct {
	CategoryName        string `json:"category_name"`
	CategoryDescription string `json:"category_description"`
	ID                  string `json:"id"`
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) (Category, error) {
	row := q.db.QueryRow(ctx, updateCategory, arg.CategoryName, arg.CategoryDescription, arg.ID)
	var i Category
	err := row.Scan(&i.ID, &i.CategoryName, &i.CategoryDescription)
	return i, err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET category_id = $1, product_name = $2
WHERE id = $3
RETURNING id, category_id, product_name
`

type UpdateProductParams struct {
	CategoryID  string `json:"category_id"`
	ProductName string `json:"product_name"`
	ID          string `json:"id"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProduct, arg.CategoryID, arg.ProductName, arg.ID)
	var i Product
	err := row.Scan(&i.ID, &i.CategoryID, &i.ProductName)
	return i, err
}

const updatePurchase = `-- name: UpdatePurchase :one
UPDATE purchases
SET total_price = $1, quantity = $2
WHERE id = $3
RETURNING id, product_id, total_price, quantity, vendor_id, created_at, cashier_id
`

type UpdatePurchaseParams struct {
	TotalPrice int32  `json:"total_price"`
	Quantity   int32  `json:"quantity"`
	ID         string `json:"id"`
}

func (q *Queries) UpdatePurchase(ctx context.Context, arg UpdatePurchaseParams) (Purchase, error) {
	row := q.db.QueryRow(ctx, updatePurchase, arg.TotalPrice, arg.Quantity, arg.ID)
	var i Purchase
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.TotalPrice,
		&i.Quantity,
		&i.VendorID,
		&i.CreatedAt,
		&i.CashierID,
	)
	return i, err
}

const updateSales = `-- name: UpdateSales :one
UPDATE sales
SET unit_price = $1, quantity = $2
WHERE id = $3
RETURNING id, product_id, unit_price, quantity, created_at, cashier_id
`

type UpdateSalesParams struct {
	UnitPrice int32  `json:"unit_price"`
	Quantity  int32  `json:"quantity"`
	ID        string `json:"id"`
}

func (q *Queries) UpdateSales(ctx context.Context, arg UpdateSalesParams) (Sale, error) {
	row := q.db.QueryRow(ctx, updateSales, arg.UnitPrice, arg.Quantity, arg.ID)
	var i Sale
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.UnitPrice,
		&i.Quantity,
		&i.CreatedAt,
		&i.CashierID,
	)
	return i, err
}
